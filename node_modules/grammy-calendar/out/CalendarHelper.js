"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CalendarHelper_instances, _CalendarHelper_options, _CalendarHelper_addHeader, _CalendarHelper_addDays, _CalendarHelper_addShortcutButtons, _CalendarHelper_normalizeWeekDay, _CalendarHelper_getMinDay, _CalendarHelper_getMaxDay, _CalendarHelper_isInMinMonth, _CalendarHelper_isInMaxMonth;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarHelper = void 0;
const deps_node_js_1 = require("./deps.node.js");
const DEFAULT_OPTIONS = {
    startWeekDay: 1,
    weekDayNames: ["S", "M", "T", "W", "T", "F", "S"],
    monthNames: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
    ],
    ignoreWeekDays: [],
    hideIgnoredWeeks: false,
    shortcutButtons: [],
};
class CalendarHelper {
    constructor(options) {
        _CalendarHelper_instances.add(this);
        _CalendarHelper_options.set(this, void 0);
        __classPrivateFieldSet(this, _CalendarHelper_options, Object.assign({ ...DEFAULT_OPTIONS, defaultDate: new Date() }, options), "f");
    }
    getCalendarMarkup(inputDate) {
        let date = inputDate;
        // I use a math clamp to check if the input date is in range
        if (__classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate && date < __classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate) {
            date = __classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate;
        }
        if (__classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate && date > __classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate) {
            date = __classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate;
        }
        const page = new deps_node_js_1.InlineKeyboard();
        __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_addShortcutButtons).call(this, page);
        __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_addHeader).call(this, page, date);
        __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_addDays).call(this, page, date);
        return page;
    }
}
exports.CalendarHelper = CalendarHelper;
_CalendarHelper_options = new WeakMap(), _CalendarHelper_instances = new WeakSet(), _CalendarHelper_addHeader = function _CalendarHelper_addHeader(keyboard, date) {
    const monthName = __classPrivateFieldGet(this, _CalendarHelper_options, "f").monthNames[date.getMonth()];
    const year = date.getFullYear();
    if (__classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_isInMinMonth).call(this, date)) {
        // this is min month, I push an empty button
        keyboard.text(" ", "calendar-telegram-ignore-minmonth");
    }
    else {
        keyboard.text("<", "calendar-telegram-prev-" + toYyyymmdd(date));
    }
    keyboard.text(`${monthName} ${year}`, "calendar-telegram-ignore-monthname");
    if (__classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_isInMaxMonth).call(this, date)) {
        // this is max month, I push an empty button
        keyboard.text(" ", "calendar-telegram-ignore-maxmonth");
    }
    else {
        keyboard.text(">", "calendar-telegram-next-" + toYyyymmdd(date));
    }
    keyboard.row();
    const weekDays = [
        ...__classPrivateFieldGet(this, _CalendarHelper_options, "f").weekDayNames.slice(__classPrivateFieldGet(this, _CalendarHelper_options, "f").startWeekDay),
        ...__classPrivateFieldGet(this, _CalendarHelper_options, "f").weekDayNames.slice(0, __classPrivateFieldGet(this, _CalendarHelper_options, "f").startWeekDay),
    ];
    keyboard.add(...weekDays.map((e, i) => ({
        text: e,
        callback_data: `calendar-telegram-ignore-weekday-${i}`,
    })));
}, _CalendarHelper_addDays = function _CalendarHelper_addDays(keyboard, date) {
    const maxMonthDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    const maxDay = __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_getMaxDay).call(this, date);
    const minDay = __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_getMinDay).call(this, date);
    let daysOfWeekProcessed = 0, daysOfWeekIgnored = 0;
    let currentRow = buildFillerRow("firstRow-");
    for (let d = 1; d <= maxMonthDay; d++) {
        date.setDate(d);
        const weekDay = __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_normalizeWeekDay).call(this, date.getDay());
        if (d < minDay || d > maxDay) {
            if (!__classPrivateFieldGet(this, _CalendarHelper_options, "f").hideIgnoredWeeks ||
                __classPrivateFieldGet(this, _CalendarHelper_options, "f").ignoreWeekDays.includes(weekDay)) {
                currentRow[weekDay] = {
                    text: strikethroughText(d.toString()),
                    callback_data: "calendar-telegram-ignore-" + toYyyymmdd(date),
                };
            }
            daysOfWeekIgnored++;
        }
        else {
            currentRow[weekDay] = {
                text: d.toString(),
                callback_data: "calendar-telegram-date-" + toYyyymmdd(date),
            };
        }
        daysOfWeekProcessed++;
        if (weekDay == 6 || d == maxMonthDay) {
            if (!__classPrivateFieldGet(this, _CalendarHelper_options, "f").hideIgnoredWeeks ||
                daysOfWeekProcessed !== daysOfWeekIgnored) {
                keyboard.row(...currentRow);
            }
            // I'm at the end of the row: I create a new filler row
            currentRow = buildFillerRow("lastRow-");
            daysOfWeekProcessed = 0;
            daysOfWeekIgnored = 0;
        }
    }
}, _CalendarHelper_addShortcutButtons = function _CalendarHelper_addShortcutButtons(keyboard) {
    if (__classPrivateFieldGet(this, _CalendarHelper_options, "f").shortcutButtons.length > 0) {
        keyboard.add(...__classPrivateFieldGet(this, _CalendarHelper_options, "f").shortcutButtons);
        keyboard.row();
    }
}, _CalendarHelper_normalizeWeekDay = function _CalendarHelper_normalizeWeekDay(weekDay) {
    const result = weekDay - __classPrivateFieldGet(this, _CalendarHelper_options, "f").startWeekDay;
    return result < 0 ? result + 7 : result;
}, _CalendarHelper_getMinDay = function _CalendarHelper_getMinDay(date) {
    let minDay;
    if (__classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate && __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_isInMinMonth).call(this, date)) {
        minDay = __classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate.getDate();
    }
    else {
        minDay = 1;
    }
    return minDay;
}, _CalendarHelper_getMaxDay = function _CalendarHelper_getMaxDay(date) {
    let maxDay;
    if (__classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate && __classPrivateFieldGet(this, _CalendarHelper_instances, "m", _CalendarHelper_isInMaxMonth).call(this, date)) {
        maxDay = __classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate.getDate();
    }
    else {
        maxDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    }
    return maxDay;
}, _CalendarHelper_isInMinMonth = function _CalendarHelper_isInMinMonth(date) {
    return __classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate
        ? isSameMonth(__classPrivateFieldGet(this, _CalendarHelper_options, "f").minDate, date)
        : false;
}, _CalendarHelper_isInMaxMonth = function _CalendarHelper_isInMaxMonth(date) {
    return __classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate
        ? isSameMonth(__classPrivateFieldGet(this, _CalendarHelper_options, "f").maxDate, date)
        : false;
};
/**
 * Builds an array of seven ignored callback buttons
 * @param {*String} prefix String to be added before the element index
 */
const buildFillerRow = (prefix) => {
    const buttonKey = "calendar-telegram-ignore-filler-" + prefix;
    return Array.from({ length: 7 }, (_v, k) => ({
        text: " ",
        callback_data: `${buttonKey}${k}`,
    }));
};
/**
 * This uses unicode to draw strikethrough on text
 * @param {*String} text text to modify
 */
const strikethroughText = (text) => text.split("").reduce(function (acc, char) {
    return acc + char + "\u0336";
}, "");
/**
 * Check if myDate is in same year and month as testDate
 * @param {*Date} myDate input date
 * @param {*Date} testDate test date
 * @returns bool
 */
const isSameMonth = (myDate, testDate) => {
    if (!myDate)
        return false;
    testDate = testDate || new Date();
    return (myDate.getFullYear() === testDate.getFullYear() &&
        myDate.getMonth() === testDate.getMonth());
};
const toYyyymmdd = (date) => {
    const mm = date.getMonth() + 1; // getMonth() is zero-based
    const dd = date.getDate();
    return [
        date.getFullYear(),
        `${mm > 9 ? "" : "0"}${mm}`,
        `${dd > 9 ? "" : "0"}${dd}`,
    ].join("-");
};
